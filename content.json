[{"title":"套件管理工具","url":"/package-manage-6ac39b2a/","content":"\nnpm(node package manager)套件管理工具，可將想要的 node 套件，透過 npm 安裝在 local 專案位置或全域性電腦環境中。\n\nnpm v5.2.0 後內建了一個指令`npx`，也是一種 CLI 工具，可以讓我們更方便的安裝或管理依賴(dependencies)。\n\n<!-- more -->\n\n> `NPM` - Manage packages but doesn't make life easy executing any.\n> `NPX` - A tool for executing Node packages. (bundled with NPM version 5.2+)\n\n## `npm` (the package manager)\n\n需要先將想要用的套件，透過指令安裝後，會記錄在`package.json`\n\n並且會需要將套件都下載到對應的 `node_modules` 資料夾中\n\n例如：\nlocal 環境，就會安裝在 `./node_modules/.bin`的資料夾。\nglobal 環境，就會安裝在 global 環境的 `/bin`資料夾(e.g. `/usr/local/bin`)\n\n## `npx` (the package runner)\n\n`NPM version 5.2+`推出的 CLI 工具，其用意是更方便管理與安裝 npm 套件，可直接執行未安裝過的套件。\n\n- 檢查是否有 npx\n\n```sh\nwhich npx\n```\n\n- 如果沒有的話，可透過以下指令安裝\n\n```sh\nnpm install -g npx\n```\n\n## `yarn`\n\n主要由 Facebook 團隊與 Exponent、Google、Tilde 所合作開發的套件管理工具。\n安裝套件速度比 npm 快速。\n\n## `npm` 與 `yarn` 指令比較\n\n| npm 指令                                       | yarn 指令                   | 說明                                     |\n| ---------------------------------------------- | --------------------------- | ---------------------------------------- |\n| `npm install`                                  | `yarn install`              | 安裝 json.package 所有依賴               |\n| `npm install [package]`                        | `(N/A)`                     | Yarn 不支援直接安裝套件                  |\n| `npm install --save [package]`                 | `yarn add [package]`        | 儲存在 json.package 中的 dependencies    |\n| `npm install --save-dev [package]`             | `yarn add [package] --dev`  | 儲存在 json.package 中的 devDependencies |\n| `npm install --global [package]`               | `yarn global add [package]` | 安裝在全域環境中                         |\n| `npm uninstall [package]`                      | `(N/A)`                     | Yarn 不支援直接安裝或移除套件            |\n| `npm uninstall [package] --save [package]`     | `yarn remove [package]`     | 移除 dependencies 某套件                 |\n| `npm uninstall [package] --save-dev [package]` | `yarn remove [package]`     | 移除 devDependencies 某套件              |\n| `rm -rf node_modules && npm install`           | `yarn upgrade`              | 更新 node_modules                        |\n\n---\n\n#### 參考\n\n- [Yarn 官網 - 最常用的命令](https://classic.yarnpkg.com/zh-Hant/docs/usage)\n- [[Day-5] 用 Yarn 取代 npm 加速開發](https://ithelp.ithome.com.tw/articles/10191745)\n\n<br>\n","categories":["工欲善其事"]},{"title":"git ssh-agent教學","url":"/git-ssh-agent-3191a3b8/","content":"\n自動啟動 ssh-agent，免除重複輸入金鑰密碼\n\n<!-- more -->\n\n- config\n\n```bash\nHost *\n  IdentityFile ~/.ssh/xxx_rsa\n  # mac重開機後，ssh agent可能遺失的解法?\n  UseKeychain yes\n  AddKeysToAgent yes\n```\n\n- 將 host 加入 agent\n\n```bash\nssh-add -K ~/.ssh/xxx_rsa\n```\n\n- 查看目前加入 ssh-agent 列表\n\n```bash\nssh-add -l\n```\n\n## mac automator\n\nmac 重新開機後，可能遇到 ssh agent 遺失\n\n所以需要建立一個自動執行的腳本\n\n1. automator 打開後，選擇「執行 Shell 工序指令(run shell script)」\n\n![](/images/automator01.png)\n\n![](/images/automator02.png)\n\n2. 設定 > 使用者與群組 > 登入項目\n   加入剛剛製作的 script 開機時就會自動執行。\n\n![](/images/automator03.png)\n","tags":["git"],"categories":["工欲善其事"]},{"title":"flutter 多國語系設定","url":"/flutter-i18n-translate-869ccd78/","content":"\nflutter 使用`.arb`檔案格式(Application Resource Bundle)存放多國語系，其內容結構就類似 json\n\n<!-- more -->\n\n- [arb 介紹](https://github.com/google/app-resource-bundle/wiki/ApplicationResourceBundleSpecification)\n\n## IDE 套件 - **flutter intl**\n\n`android studio` 跟 `vscode` 皆有這個外掛可使用\n\n建立各語系的 arb 檔，套件就會自動轉成 dart\n\nDart 官方提供 Intl Libraray，做多語系切換功能\n\n---\n\n## 實作\n\n1. 讀取 arb 檔案的 key\n\n```Dart\n  S.of(context).title\n```\n\n2. plural 方法，提供翻譯不同情境\n\n- en.arb\n\n```json\n{\n  \"numberOfSongsAvailable\": \"{count, plural, =0 {No songs found.} =1 {One song found.} =2 {{count} songs found.} few {{count} songs found.} many {{count} songs found.} other {{count} song found.}}\",\n  \"@numberOfSongsAvailable\": {\n    \"type\": \"Text\",\n    \"placeholders\": {\n      \"count\": {\n        \"type\": \"num\"\n      }\n    },\n    \"description\": \"number of songs plural\",\n    \"context\": \"plurals\"\n  }\n}\n```\n\n- l10n.dart\n\n```Dart\nString numberOfSongsAvailable(int count) => Intl.plural(count,\n  zero: 'No songs found.',\n  one: 'One song found.',\n  two: '$count songs found.',\n  few: '$count songs found.',\n  other: '$count song found.',\n  many: '$count songs found.',\n  name: 'numberOfSongsAvailable',\n  args: [count],\n  desc: 'number of songs plural');\n```\n\n- Widget\n\n```Dart\n// plurals\nprint(l10n.numberOfSongsAvailable(0));\nprint(l10n.numberOfSongsAvailable(1));\nprint(l10n.numberOfSongsAvailable(2));\nprint(l10n.numberOfSongsAvailable(5));\nprint(l10n.numberOfSongsAvailable(10));\n```\n\n---\n\n## google sheets 匯入多語系檔案\n","tags":["flutter"],"categories":["flutter"]},{"title":"flutter JSON與序列化","url":"/flutter-json-and-serialization-7dae1368/","content":"\nflutter處理JSON與序列化，官方推薦有以下兩種方式：\n\n<!-- more -->\n\n## 手動序列化\n\n- user.dart\n\n```Dart\nclass User {\n  final String name;\n  final String email;\n\n  User(this.name, this.email);\n\n  User.fromJson(Map<String, dynamic> json)\n    : name = json['name'],\n      email = json['email'];\n\n  Map<String, dynamic> toJson() =>\n    {\n      \"name\": name,\n      \"email\": email\n    };\n}\n```\n\n- 調用 `jsonDecode()` 方法來解碼 JSON\n\n```Dart\nimport 'dart:convert';\n\nMap userMap = jsonDecode(jsonString);\nvar user = user.fromJson(userMap);\n\nprint(\"${user['name']}!\");\nprint(\"We sent the verfication link to ${user['email']}\");\n```\n\n## 透過程式碼生成自動序列化\n\n### 官方推薦：**json_serializable**\n\n#### 設置 json_serializable\n\n- pubspec.yaml\n\n```yaml\ndependencies:\n  json_annotation: ^2.0.0\n\ndev_dependencies:\n  build_runner: ^1.0.0\n  json_serializable: ^2.0.0\n```\n\n#### 以 json_serializble 方式創建 Model\n\n- user.dart\n\n```dart\nimport 'package:json_annotation/json_annotation.dart';\n\n// 允許user.dart存取這些產生檔案中的私有成員\npart 'user.g.dart';\n\n// 這個修飾符是用來告訴生成器，這個class是要產生Model用的\n@JsonSerializable()\nclass User {\n  User();\n\n  String user;\n  int phone;\n  // @JsonKey -> 自定義命名\n  @JsonKey(name: \"register_email\")\n  String email;\n  // defaultValue: 假設json沒有該key或value為null的預設值\n  @JsonKey(defaultValue: false)\n  final bool hasCar;\n\n  // factory宣告，從map創建新的Model實例\n  factory User.fromJson(Map<String, dynamic> json) => _$UserFromJson(json);\n\n  // `toJson`\n  Map<String, dynamic> toJson() => _$UserToJson(this);\n}\n```\n\n- 透過指令生成 code\n\n```bash\n# One-time code generation\n# 一次性生成檔案\nflutter pub run build_runner\n\n# Generating code continuously\n# 透過 Watcher 監聽專案變化\nflutter pub run build_runner watch\n```\n\n\n### 參考\n\n- [flutter - JSON and serialization](https://flutter.dev/docs/development/data-and-backend/json)\n\n<br>","tags":["flutter"],"categories":["flutter"]},{"title":"flutter串接資料","url":"/flutter-fetch-data-f25e03ed/","content":"\n紀錄flutter基本讀取資料處理\n\n<!-- more -->\n\n### 1. 新增 `http` package\n\n- pubspec.yaml\n\n```yaml\ndependencies:\n  http: <latest_version>\n```\n\n- example.dart\n\n```dart\nimport 'package:http/http.dart' as http;\n```\n\n---\n\n### 2. 發送 network request\n\n```dart\nFuture<http.Response> fetchAlbum() {\n  return this.http('<api_url>');\n}\n```\n\n---\n\n#### 非同步相關：`Future、async、await`\n\n**Future**：一個 class，用來表示非同步操作的結果，並且擁有兩個狀態，完成(completed)與未完成(uncompleted)。\n\n**asyc**：關鍵字，用於區分 function 是同步或不同步，使用方法是在定義 function 時加上`async`。\n\n**await**：只能在非同步 function 中才能使用 await，用來等待非同步工作的完成結果，使用 await 有助於程式碼的易讀性。\n\n- [Asynchronous programming: futures, async, await @dart](https://dart.dev/codelabs/async-await#what-is-a-future)\n\n---\n\n### 3. 將 response 轉換成 Dart 自定義類別 Model\n\n- 建立一個新 Class\n\n```dart\nclass Album {\n  final int userId;\n  final int id;\n  final String title;\n\n  Album({this.userId, this.id, this.title});\n\n  factory Album.fromJson(Map<String, dynamic> json) {\n    return Album(\n      userId: json['userId'],\n      id: json['id'],\n      title: json['title']\n    );\n  }\n}\n\n```\n\n- 將`http.response`轉換成自定義 Class\n\n```dart\nFuture<Album> fetchAlbum() async {\n  final response = await http.get('<api_url>');\n\n  if (response.statusCode === 200) {\n    return Album.fromJson(json.decode(response.body));\n  } else {\n    throw Exception('Failed to load album.');\n  }\n}\n```\n\n---\n\n### 4. 取得資料\n\n```dart\nclass _MyAppState extends State<MyApp> {\n  Future<Album> futureAlbum;\n\n  @override\n  void initState() {\n    super.initState();\n    futureAlbum = fetchAlbum();\n  }\n}\n```\n\n---\n\n### 5. 顯示資料\n\n```java\nFutureBuilder<Album>(\n  future: futureAlbum,\n  builder: (context, snapshot) {\n    if (snapshot.hasData) {\n      return Text(snapshot.data.title);\n    } else if (snapshot.hasError) {\n      return Text(\"${snapshot.error}\");\n    }\n\n    // By default, show loading spinner.\n    return CircularProgressIndicator();\n  },\n);\n\n```\n\n> 不建議直接在 build()方法裡面調用 fetch()，因為每次需要刷新畫面時，flutter 都會調用 build()方法。如果在 build()中調用 fetch，將會使不必要的調用氾濫，進而降低 app 的速度。\n\n\n### 參考\n\n- [flutter - cookbook #networking](https://flutter.dev/docs/cookbook#networking)","tags":["flutter"],"categories":["flutter"]},{"title":"管理多個git帳號","url":"/git-ssh-6efbc176/","content":"\n1. 產生 SSH-Key 並儲存至指定位置\n\n```yaml\nssh-keygen -t rsa -b 4096 -C \"your_email@example.com\"\n# enerating public/private rsa key pair.\n# Enter file in which to save the key (/Users/Username/.ssh/id_rsa): (輸入指定位置)\n```\n\n<!-- more -->\n\n- 產生後若想確認是否操作成功，可以再下指令查看是否有成功新增 ssh-Key 並儲存至指定位置\n\n```yaml\nls -al ~/.ssh\n```\n\n2. 將 ssh public key 貼至 github 中\n\n3. **將私鑰加到 ssh-agent 中 (最重要的步驟)**\n\n```yaml\n# 列出已加入ssh-agent的帳號有哪些\nssh-add -l\n# The agent has no identities.\n\nssh-add ~/.ssh/id_rsa\n# Identity added: id_rsa (username@address)\n\n# 再檢查是否有加入成功\nssh-add -l\n# 4096 SSH256:xxxxxxxxxxxx username@address (RSA)\n```\n\n4. 修改 Config 檔資料\n\n```yaml\n# Default Github\nHost github.com\n  HostName github.com\n  User Yourname\n  IdentityFile ~/.ssh/id_rsa\n\n# Company\nHost git-company\n  HostName company.com\n  User Yourname\n  IdentityFile ~/.ssh/id_rsa_company\n```\n\n5. 測試連結是否正常\n\n```yaml\nssh -T git@git-company\n# Hi Username! You'v successfully authenticated, but Github does not provide shell access.\n```\n\n6. clone 遠端資料\n\n```yaml\ngit clone git@git-company:Username/repository\n```\n\n7. 取消 Global 設定並設定各 Repository 的 User 資料\n   (不取消的話，預設使用 global 設定)\n\n```yaml\n# 取消Global設定\ngit config -global -unset user.name\ngit config -global -unset user.email\n\n# 設定各Repository的User資料\ngit config user.email \"username@address\"\ngit config user.name \"UserName\"\n```\n\n<br>\n","tags":["git"],"categories":["工欲善其事"]},{"title":"[筆記] JavaScript的Hoisting","url":"/javascript-hoisting-11da879d/","content":"\n紀錄一下 Hoisting 的觀念與使用。\n一般在寫程式的時候，我們都會定義好變數，才會去使用它。\n然而在尚未定義的情況下，直接去使用這個變數，通常都會出現錯誤訊息！\n\n<!-- more -->\n\n首先，先來看 w3schools 跟 MDN 對於 Hoisting 的說明\n\n#### w3school 的說明\n\n> Hoisting is JavaScript's default behavior of moving declarations to the top.\n\n#### MDN 的說明\n\n> 提升(Hoisting)是一種釐清 JavaScript 在執行階段內文如何運行的思路(尤其在創建和執行階段)。\n> 然而，提升一詞可能會引起誤解：例如，提升看起來是單純地將變數和函式宣告，移動到程式的區塊頂端，然而必非如此。變數和函式的宣告會在編譯階段就被放入記憶體，但實際位置和程式碼中完全一樣。\n\n意思是在 JavaScript 中，它會把定義的變項一到最前面先執行。\n\n```js\nb();\nconsole.log(a);\n\nvar a = 'Hello World!';\n\nfunction b() {\n  console.log('called b!');\n}\n```\n\n所以執行上述的程式碼後，會得到以下結果：\n\n```js\ncalled b!\nundefined\n```\n\n結果當中並沒有發生任何錯誤，因為其實在程式一開始執行的時候，就已經把`var a`和`function b(){...}` 這些宣告(declare)都存在記憶體中了，但還沒有把值指定進去變項當中。\n\n---\n\n#### 閱讀參考\n\n- [提升(Hoisting) - MDN](https://developer.mozilla.org/zh-TW/docs/Glossary/Hoisting)\n- [JavaScript Hoisting - w3schools](https://www.w3schools.com/js/js_hoisting.asp)\n\nhttps://blog.techbridge.cc/2018/11/10/javascript-hoisting/\nhttps://pjchender.blogspot.com/2015/12/javascript-hoisting.html\nhttps://stackoverflow.com/questions/336859/var-functionname-function-vs-function-functionname\n","tags":["JavaScript"],"categories":["JavaScript"]},{"title":"關於git commit規範","url":"/git-commit-rules-1aeec585/","content":"\n如何撰寫一個好的 commit message，以及工具使用\n\n<!-- more -->\n\n## Git commit message 的七條規則\n\n1. 用一行空白行分隔標題與內容\n2. 限制標題最多只有 50 字元\n3. 標題開頭要大寫\n4. 標題不以句點結尾\n5. 以祈使句撰寫標題\n6. 內文每行最多 72 字元\n7. 用內文解釋 _what_ 以及 _why_ v.s. _how_\n\n### 1. 用一行空白行分隔標題與內容\n\n首先，不是所有的 commit message 都同時需要標題與內文。\n有時候一行文也很好，尤其是改變很簡單，以至於不需要進一步的脈絡敘述。\n\n在任何情況下，標題與內文的分隔會在瀏覽 log 的時候看出。\n\n### 2. 限制標題最多只有 50 字元\n\n讓標題保持在 50 字以下能夠確保標題的可讀性，並強迫作者思考如何用更簡潔的方式表達發生什麼事情。\n\n> 如果很難總結出標題，這代表你可能在一個 commit 裡面做了太多的改變。請盡量讓 commit 單一化，一次只更動一個主題(atomic commits)。\n\n### 3. 標題開頭要大寫\n\n任何標題的開頭都要大寫。\n\n舉例而言：\n\n- <span style=\"color:green\">Accelerate to 88 miles per hour</span>\n\n而不是：\n\n- <span style=\"color:red\">accelerate to 88 miles per hour</span>\n\n### 4. 標題不以句點結尾\n\n結尾的標點符號在標題列是多餘的。此外，當你要遵守`50字或以下的規則`時，字元空間是很寶貴的。\n\n### 5. 以祈使句撰寫標題\n\n祈使句有時聽起來有點不禮貌；因此我們並不常使用。\n但是對於 Git commit 標題來說卻很適合。其中一個理由是因為**Git 本身就是依照你的命令來完成一個動作**。\n\n### 6. 內文每行最多 72 字\n\nGit 不會把任何文字自動換行。當你在撰寫 commit message 內文的時候，你需要注意左邊的 margin，並且手動將超過 margin 的文字換到下一行。\n\n### 7. 用內文解釋 what 以及 why vs. how\n\n在大多數的情況下，你可以省略掉描述這些變更的細節。程式碼本身就已經能自我說明了 (如果程式碼太複雜，必須要有說明的話，這時候就是程式碼本身的註解啦)。你只需要專注在解釋做出這樣改變的原因 ─ 事情在改變前為什麼可行 (以及他的錯誤)，他們目前運作的狀況，以及為什麼你決定要以這個方法解決問題。\n\n<br>\n\n## Commitizen 是什麼？\n\n一個格式化 commit message 的工具。\n\n#### 全域安裝以下三個套件\n\n```bash\nnpm i -g commitizen\n```\n\n- 生成 changelog 的工具\n\n```bash\nnpm i -g conventional-changelog\nnpm i -g conventional-changelog-cli\n```\n\n#### 檢查是否安裝成功\n\n```bash\nnpm ls -g -depth=0\n```\n\n可得到以下結果\n\n```bash\n/usr/local/lib\n├── commitizen@3.1.1\n├── conventional-changelog@3.1.8\n├── conventional-changelog-cli@2.0.21\n├── hexo-cli@2.0.0\n└── npm@6.10.2\n```\n\n#### package.json 相關設定\n\n安裝完之後，還需要在`package.json`設定路徑\n因套件是裝在全域環境下的，所以可以不需要在專案安裝該套件\n\n- package.json\n\n```bash\n{\n  ...,\n  \"config\": {\n    \"commitizen\": {\n      \"path\": \"cz-conventional-changelog\"\n    }\n  }\n}\n```\n\n#### 如何使用\n\n```bash\ngit cz\n```\n\n- 如果使用**NPM 5.2+**，且不想安裝在全域環境中\n\n```bash\nnpx git-cz\n```\n\n執行成功後就會看到以下畫面\n![](/images/git-cz.png)\n\n---\n\n#### 閱讀參考\n\n- [Commitizen 的安装和使用（标准化 Git 的 Commit Message）](https://www.jianshu.com/p/d264f88d13a4)\n- [如何寫一個 Git Commit Message](https://blog.louie.lu/2017/03/21/%E5%A6%82%E4%BD%95%E5%AF%AB%E4%B8%80%E5%80%8B-git-commit-message/)\n- [cz-cli 官方](https://github.com/commitizen/cz-cli)\n","tags":["git"],"categories":["工欲善其事"]},{"title":"JS全域物件","url":"/javascript-global-object-9f77ade/","content":"\n記錄一些踩過的 JavaScript 的雷點。\n\n~~珍惜生命遠離全域物件~~\n\n<!-- more -->\n\n## window.opener\n\n情境：A 視窗透過連結打開 B 視窗，B 視窗也有連結導回 A 視窗。\n\n### MDN 說明\n\n> 當一個視窗是由另個視窗所開啟(使用`window.open`或一個帶有`target`屬性設定的連結)\n> 被開啟的這個視窗會於 **window.opener** 保留開啟它的第一個視窗之參考。\n> 假如目前視窗沒有開啟它的視窗，則會回傳 null。\n\n### <span style=\"color:red\">雷點<span>\n\n需注意開啟視窗時的 domain，是否與視窗 domain 一致\n如果不一致，就會發生 CORS 錯誤，而無法另開分頁。\n\n#### 閱讀參考\n\n- [window.opener - MDN](https://developer.mozilla.org/zh-TW/docs/Web/API/Window/opener)\n","tags":["JavaScript"],"categories":["JavaScript"]},{"title":"自動更新vscode失敗","url":"/IDE-vscode-update-789c3552/","content":"\n遇過好幾次 mac 在自動更新 vscode 的時候\n\n右下角都會跳出 `Could not create temporary directory: Permission denied` 的提示\n\n趕緊把解法給記下來啊啊\n\n<!-- more -->\n\n---\n\n`注意:` 先把 vscode 完全關閉\n\n```yaml\n# 1. 這一步是需要輸入密碼的\nsudo chown $USER ~/Library/Caches/com.microsoft.VSCode.ShipIt/\n\n# 2. 這一步是不需要輸入密碼的, 如果不進行第一步，第二步會報錯\nsudo chown $USER ~/Library/Caches/com.microsoft.VSCode.ShipIt/\n\n# 整合 1 + 2 的寫法\nsudo chown -R $USER ~/Library/Caches/com.microsoft.VSCode.ShipIt/\n\n# 3. 更新xattr\nxattr -dr com.apple.quarantine /Applications/Visual\\ Studio\\ Code.app\n```\n\n### 問題起因\n\n在 `Users/username/Library/Caches` 目錄下，有以下兩個文件\n可以看到，他們兩個的用戶是不一樣的，一個是`root`、一個是`username`\n一般來說，我是以`username`來使用我的 mac。就是因為這兩個文件的用戶不一樣，導致了更新失敗。\n\n#### 閱讀參考\n\n- [mac vscode 更新失败：Permission denied 解决办法](https://segmentfault.com/a/1190000012881106)\n","categories":["工欲善其事"]},{"title":"Node.js安裝與版本切換 for mac","url":"/node-js-install-6a6463de/","content":"\n安裝 Node.js 有很多方式，不過由於 node 更新非常快速，開發過程中很有可能會有切換 node 版本的需求。\n因此建議不要使用 mac 上常用的 **Homebrew** 來安裝 node，而是使用 **nvm (Node Version Manager)** 這個工具來安裝並且管理 node。\n\n<!-- more -->\n\n## 安裝 nvm\n\n官方建議直接使用`cURL`安裝或更新 nvm :\n\n```\ncurl -o- https://raw.githubusercontent.com/nvm-sh/nvm/v0.34.0/install.sh | bash\n```\n\n上面的指令會把 nvm repository 複製到`~/.nvm`，然後會把 source line 加進你的 profile (`~/.bash_profile`, `~/.zshrc`, `~/.profile`, or `~/.bashrc`)：\n\n```\nexport NVM_DIR=\"$HOME/.nvm\"\n[ -s \"$NVM_DIR/nvm.sh\" ] && . \"$NVM_DIR/nvm.sh\" # This loads nvm\n```\n\n在 OSX 中如果執行安裝指令之後出現 `nvm: command not found`，表示系統中沒有`.bash_profile` 這個檔案。可以透過 `touch ~/.bash_profile`建立，然後再執行一次安裝指令。\n\n- [nvm 官方安裝教學](https://github.com/nvm-sh/nvm#installation-and-update)\n\n### 檢查 nvm 是否順利安裝成功\n\n```\ncommand -v nvm\n```\n\n---\n\n## nvm 指令\n\n列出可用版本：\n\n```yaml\n# 查看有哪些 Node.js 版本可安裝\n$ nvm ls-remote\n```\n\n加上 <version> 參數 可篩選版本號：\n\n```yaml\n# 列出所有 8.x 版本資訊\n$ nvm ls-remote 8\n#     v8.9.0\n#     v8.9.1\n#     v8.9.2\n#     v8.9.3\n#     v8.9.4\n```\n\n列出本機安裝的資訊：\n\n```yaml\n$ nvm ls\n#      v8.10.0\n# ->  v10.15.3\n#       system\n```\n\n### 安裝需要的 Node.js 版本\n\n```yaml\n$ nvm install 10.16.0\n$ nvm use 10.16.0\n```\n\n### 設定預設 Node.js 版本\n\n上述安裝之後，每次重開 terminal，Node.js 的版本還是會重置\n因此需要用下面指令設定預設使用的版本：\n\n```yaml\n$ nvm alias default 10.16.0\n```\n\n---\n\n## 移除 nvm\n\n### 先移除掉相關目錄：\n\n```yaml\nrm -rf ~/.nvm\nrm -rf ~/.npm\nrm -rf ~/.bower\n```\n\n接著再到 `~/.bash_profile` (`~/.bash_profile`, `~/.zshrc`, `~/.profile`, or `~/.bashrc`)，\n把 source line 砍掉：\n\n```yaml\n# 砍掉以下內容\nexport NVM_DIR=\"$HOME/.nvm\"\n[ -s \"$NVM_DIR/nvm.sh\" ] && . \"$NVM_DIR/nvm.sh\" # This loads nvm\n```\n\n重啟 terminal，查詢以下指令，應該都沒有東西了：\n\n```yaml\nnvm\nndoe\nnpm\n```\n\n### 如果是用 Homebrew...\n\n若是碰巧之前是用 Homebrew 安裝 Node.js 的話\n\n```yaml\n$ brew uninstall node\n```\n\n一般來說，`node`套件會預設在`/usr/local/bin`，所以請將以下目錄都砍掉：\n\n```yaml\nrm -rf /usr/local/bin/node\nrm -rf /usr/local/bin/npm\nrm -rf /usr/local/bin/node_modules\n```\n\n想確認路徑到底是不是正確，可以用 `which node` 查詢。\n\n---\n\n#### 閱讀參考\n\n- [Node.js 安裝與版本切換教學 (for MAC)](http://icarus4.logdown.com/posts/175092-nodejs-installation-guide)\n- [Node.js 環境設定-for mac](https://medium.com/@toumasaya/node-js-%E7%92%B0%E5%A2%83%E8%A8%AD%E5%AE%9A-for-mac-a2628836feaf)\n","tags":["Nodejs"],"categories":["工欲善其事"]},{"title":"npm 套件管理工具","url":"/npm-bb8ed262/","content":"\nnpm 的全名為 **Node Package Manager**，是附屬在 Node.js 中的套件管理工具。\n在安裝 Node.js 時，就可以順便將 npm 安裝到電腦中。\n\n<!-- more -->\n\n## 常用語法\n\n```javascript\n// npm install\nnpm i\n\n// npm install --save-dev\nnpm i -D\n\n// npm install --save\nnpm i -S\n\n// 列出目前的node_module，-g代表全域\nnpm list\n\n// 目前安裝的套件版本\nnpm list <package_name> version\n```\n\n- [npm doc](https://docs.npmjs.com/cli/install)\n\n### `dependencies與devDependencies的差別`\n\nnpm install 的時候，有兩種指令把他們寫入 package.json 文件裡面\n--save：寫入 dependencies\n--save-dev：寫入 devDependencies\n\n#### 兩者差異：\n\ndependencies 是需要發佈到生產環境的套件。\ndevDependencies 只用於開發環境。\n\n※ dev 是 develop 的簡寫。\n\n## package-lock.json 的作用\n\npackage-lock.json 為 npm 5 新增的檔案\n每次 npm install/uninstall/undate 時，都會去更新\n\n用以紀錄當前狀態下實際安裝的各個 npm package 的具體來源與版本號。\n\n## 版本號\n\nnpm 遵守[semver](https://semver.org/lang/zh-TW/)語意化版本號的規則，使用 node-semver 來解析版本號。\n\n### 版本號的格式\n\n一般來說，一個版本號包含三個部分：\n\n```\nMAJOR.MINOR.PATCH\n```\n\nMAJOR 表示主版本號，MINOR 表示次版本號，PATCH 表示修訂號。\n它們的取值為`非負整數`，若大於零，不能在前方補零。\n另外，版本號中任何位置都不能有空格。\n\n---\n\n### 如何升級版本號\n\n升級版本號的規則主要有三個：\n\n1. 主版本號：做了不兼容的 API 修改\n2. 次版本號：做了向下兼容的功能性新增\n3. 修訂號：向下兼容的問題修正\n\n---\n\n### 版本號符號意思\n\n#### `^`\n\n表示同一主版本號中，不小於指定版本號的版本。\n例如：`^2.2.1` 對應主版本號為 2，不小於 2.2.1 的版本號，比如：2.2.1、2.2.2、2.3.0。\n\n#### `~`\n\n表示同一主版本和次版本號中，不小於指定版本號的版本\n例如：`~2.2.1` 對應主版本號為 2，次版本號為 2，不小於 2.2.1 的版本號，比如：2.2.1、2.2.2。\n\n#### `>`、`<`、`=`、`>=`、`<=`、`-`\n\n用來指定一個版本號的範圍。\n※ 注意使用 `-` 的時候，前後必須有空格。\n\n- [npm 语义化版本号](https://blog.xcatliu.com/2015/04/14/semantic_versioning_and_npm/)\n- [npm - About semantic versioning](https://docs.npmjs.com/about-semantic-versioning)\n","tags":["npm"],"categories":["工欲善其事"]},{"title":"CSS 排版","url":"/css-note-b5c155a9/","content":"\n記錄一些常用的 css。\n\n<!-- more -->\n\n## 將 footer 固定至底部\n\n- 無論 body 內容多或少，footer 的位置永遠固定在視窗最下方\n  ![](/images/css-footer.png)\n","tags":["css"]}]